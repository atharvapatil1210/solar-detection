# -*- coding: utf-8 -*-
"""Solar Yolo model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cUKPMef4qp_goXKaaSYj34QhmzJsYg2A

# Assignemt No. 1
"""

!pip install tensorflow keras kaggle opencv-python-headless

import tensorflow as tf
import cv2
import numpy as np
import os
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv2D, BatchNormalization, LeakyReLU, ZeroPadding2D, UpSampling2D, concatenate
from tensorflow.keras.regularizers import l2

import os

IMAGE_DIR = '/content/drive/MyDrive/Solar-vnit-hackathon/images'
LABEL_DIR = '/content/drive/MyDrive/Solar-vnit-hackathon/label'

image_paths = [os.path.join(IMAGE_DIR, img) for img in os.listdir(IMAGE_DIR)]
label_paths = [os.path.join(LABEL_DIR, lbl) for lbl in os.listdir(LABEL_DIR)]

import cv2
import numpy as np

def load_image(image_path):
    image = cv2.imread(image_path)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    image = cv2.resize(image, (256, 256))  # Resize to the desired size
    image = image / 255.0  # Normalize
    return image

def load_label(label_path):
    labels = []
    with open(label_path, 'r') as file:
        for line in file.readlines():
            class_id, x_center, y_center, width, height = map(float, line.strip().split())
            labels.append([class_id, x_center, y_center, width, height])
    return np.array(labels)

import cv2
import numpy as np

def load_image(image_path):
    image = cv2.imread(image_path)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    image = cv2.resize(image, (256, 256))  # Resize to the desired size
    image = image / 255.0  # Normalize
    return image

def load_label(label_path):
    labels = []
    # Try opening the file with 'latin-1' encoding
    with open(label_path, 'r', encoding='latin-1') as file:
        for line in file.readlines():
            class_id, x_center, y_center, width, height = map(float, line.strip().split())
            labels.append([class_id, x_center, y_center, width, height])
    return np.array(labels)

import cv2
import numpy as np

def load_image(image_path):
    image = cv2.imread(image_path)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    image = cv2.resize(image, (256, 256))  # Resize to the desired size
    image = image / 255.0  # Normalize
    return image

def load_label(label_path):
    labels = []
    try:
        # Attempt to open and parse as text
        with open(label_path, 'r') as file:
            for line in file.readlines():
                class_id, x_center, y_center, width, height = map(float, line.strip().split())
                labels.append([class_id, x_center, y_center, width, height])
    except ValueError:
        print(f"Failed to parse {label_path} as text. Skipping.")
        return np.array([])  # Return an empty array for problematic files

    return np.array(labels)

def preprocess_labels(labels, grid_size=13, num_classes=1):
    y_true = np.zeros((grid_size, grid_size, 3, 5 + num_classes))

    for label in labels:
        class_id, x_center, y_center, width, height = label
        i = int(x_center * grid_size)
        j = int(y_center * grid_size)
        y_true[j, i, :, 0:4] = [x_center, y_center, width, height]
        y_true[j, i, :, 4] = 1.0  # Confidence
        y_true[j, i, :, 5 + int(class_id)] = 1.0  # One-hot class

    return y_true

grid_size = 13
num_classes = 1

y_true = np.array([preprocess_labels(lbl, grid_size, num_classes) for lbl in labels])

import tensorflow as tf

def data_generator(images, labels, batch_size=32):
    while True:
        for start in range(0, len(images), batch_size):
            end = min(start + batch_size, len(images))
            batch_images = images[start:end]
            batch_labels = labels[start:end]
            yield batch_images, batch_labels

batch_size = 32
train_gen = data_generator(images, y_true, batch_size)

def create_yolo_model(input_shape):
    inputs = tf.keras.layers.Input(input_shape)
    x = tf.keras.layers.Conv2D(32, (3, 3), activation='relu', padding='same')(inputs)
    x = tf.keras.layers.MaxPooling2D((2, 2))(x)
    x = tf.keras.layers.Conv2D(64, (3, 3), activation='relu', padding='same')(x)
    x = tf.keras.layers.MaxPooling2D((2, 2))(x)
    x = tf.keras.layers.Conv2D(128, (3, 3), activation='relu', padding='same')(x)
    x = tf.keras.layers.MaxPooling2D((2, 2))(x)
    x = tf.keras.layers.Flatten()(x)
    x = tf.keras.layers.Dense(512, activation='relu')(x)
    output = tf.keras.layers.Dense(grid_size * grid_size * 3 * (5 + num_classes))(x)
    output = tf.keras.layers.Reshape((grid_size, grid_size, 3, 5 + num_classes))(output)

    model = tf.keras.models.Model(inputs, output)
    return model

model = create_yolo_model((256, 256, 3))
model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=1e-4), loss='binary_crossentropy')

steps_per_epoch = len(images) // batch_size
model.fit(train_gen, steps_per_epoch=steps_per_epoch, epochs=3)
print(steps_per_epoch)

